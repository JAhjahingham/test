import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';

const FPSGame = () => {
  const containerRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const playerRef = useRef({ x: 0, y: 1.6, z: 0, vx: 0, vy: 0, vz: 0 });
  const keysRef = useRef({});
  const enemiesRef = useRef([]);
  const bulletsRef = useRef([]);
  const [score, setScore] = useState(0);
  const scoreRef = useRef(0);

  useEffect(() => {
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 100, 1000);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(playerRef.current.x, playerRef.current.y, playerRef.current.z);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    containerRef.current.appendChild(renderer.domElement);

    sceneRef.current = scene;
    cameraRef.current = camera;
    rendererRef.current = renderer;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 50, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // Ground
    const groundGeom = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
    const ground = new THREE.Mesh(groundGeom, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Buildings for cover
    for (let i = 0; i < 5; i++) {
      const w = Math.random() * 10 + 5;
      const h = Math.random() * 15 + 10;
      const d = Math.random() * 10 + 5;
      const geom = new THREE.BoxGeometry(w, h, d);
      const mat = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(Math.random() * 100 - 50, h / 2, Math.random() * 100 - 50);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);
    }

    // Weapon (simple cube in front of camera)
    const weaponGeom = new THREE.BoxGeometry(0.3, 0.3, 1);
    const weaponMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
    const weapon = new THREE.Mesh(weaponGeom, weaponMat);
    weapon.position.set(0.3, -0.5, -0.7);
    camera.add(weapon);

    // Enemy spawn function
    const spawnEnemy = () => {
      const geom = new THREE.BoxGeometry(0.8, 1.8, 0.8);
      const mat = new THREE.MeshLambertMaterial({ color: 0xff3333 });
      const enemy = new THREE.Mesh(geom, mat);
      enemy.position.set(Math.random() * 60 - 30, 0.9, Math.random() * 60 - 30 + 40);
      enemy.castShadow = true;
      enemy.receiveShadow = true;
      scene.add(enemy);
      enemiesRef.current.push({
        mesh: enemy,
        x: enemy.position.x,
        z: enemy.position.z,
        health: 100,
        shootTimer: 0
      });
    };

    // Initial spawns
    for (let i = 0; i < 3; i++) spawnEnemy();

    // Input handling
    const onKeyDown = (e) => { keysRef.current[e.key.toLowerCase()] = true; };
    const onKeyUp = (e) => { keysRef.current[e.key.toLowerCase()] = false; };
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    // Mouse look
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
    const onMouseMove = (e) => {
      if (document.pointerLockElement === containerRef.current) {
        euler.setFromQuaternion(camera.quaternion);
        euler.rotateY(-e.movementX * 0.005);
        euler.rotateX(-e.movementY * 0.005);
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        camera.quaternion.setFromEuler(euler);
      }
    };
    window.addEventListener('mousemove', onMouseMove);

    // Mouse click for shooting
    const onClick = () => {
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(camera.quaternion);
      const bullet = {
        pos: camera.position.clone(),
        dir: direction,
        life: 100
      };
      bulletsRef.current.push(bullet);
    };
    window.addEventListener('click', onClick);

    // Pointer lock
    document.addEventListener('pointerlockchange', () => {});
    containerRef.current.addEventListener('click', () => {
      containerRef.current.requestPointerLock();
    });

    let lastTime = Date.now();
    const animate = () => {
      requestAnimationFrame(animate);
      const now = Date.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      // Player movement
      const moveSpeed = 30;
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

      if (keysRef.current['w']) playerRef.current.vz += moveSpeed * dt;
      if (keysRef.current['s']) playerRef.current.vz -= moveSpeed * dt;
      if (keysRef.current['a']) playerRef.current.vx -= moveSpeed * dt;
      if (keysRef.current['d']) playerRef.current.vx += moveSpeed * dt;
      if (keysRef.current[' '] && playerRef.current.y <= 1.65) playerRef.current.vy = 15;

      playerRef.current.vy -= 30 * dt;
      playerRef.current.y += playerRef.current.vy * dt;
      if (playerRef.current.y < 1.6) {
        playerRef.current.y = 1.6;
        playerRef.current.vy = 0;
      }

      const moveDir = forward.multiplyScalar(playerRef.current.vz).add(right.multiplyScalar(playerRef.current.vx));
      playerRef.current.x += moveDir.x * dt;
      playerRef.current.z += moveDir.z * dt;
      playerRef.current.vx *= 0.9;
      playerRef.current.vz *= 0.9;

      camera.position.set(playerRef.current.x, playerRef.current.y, playerRef.current.z);

      // Update bullets
      bulletsRef.current = bulletsRef.current.filter(b => {
        b.pos.addScaledVector(b.dir, 80 * dt);
        b.life--;
        if (b.life <= 0) return false;

        for (let i = 0; i < enemiesRef.current.length; i++) {
          const e = enemiesRef.current[i];
          if (b.pos.distanceTo(e.mesh.position) < 1) {
            e.health -= 50;
            if (e.health <= 0) {
              scene.remove(e.mesh);
              enemiesRef.current.splice(i, 1);
              scoreRef.current += 100;
              setScore(scoreRef.current);
              if (Math.random() < 0.3) spawnEnemy();
            }
            return false;
          }
        }
        return true;
      });

      // Update enemies
      enemiesRef.current.forEach((e, i) => {
        const dx = playerRef.current.x - e.x;
        const dz = playerRef.current.z - e.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist > 0.5) {
          e.x += (dx / dist) * 15 * dt;
          e.z += (dz / dist) * 15 * dt;
        }
        e.mesh.position.set(e.x, 0.9, e.z);
        e.shootTimer++;
        if (e.shootTimer > 60 && dist < 50) {
          const dir = new THREE.Vector3(dx, 0, dz).normalize();
          bulletsRef.current.push({
            pos: new THREE.Vector3(e.x, 1, e.z),
            dir: dir,
            life: 100
          });
          e.shootTimer = 0;
        }
      });

      if (enemiesRef.current.length === 0 && scoreRef.current > 0) {
        for (let i = 0; i < Math.min(3, scoreRef.current / 300 + 1); i++) spawnEnemy();
      }

      renderer.render(scene, camera);
    };
    animate();

    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('keydown', onKeyDown);
      window.removeEventListener('keyup', onKeyUp);
      window.removeEventListener('click', onClick);
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('mousemove', onMouseMove);
      containerRef.current?.removeChild(renderer.domElement);
    };
  }, []);

  return (
    <div ref={containerRef} style={{ width: '100vw', height: '100vh', margin: 0, padding: 0, overflow: 'hidden' }}>
      <div style={{ position: 'absolute', top: 10, left: 10, color: 'white', fontSize: 24, fontFamily: 'Arial', zIndex: 10 }}>
        Score: {score}
      </div>
      <div style={{ position: 'absolute', top: 50, left: 10, color: 'white', fontSize: 16, fontFamily: 'Arial', zIndex: 10 }}>
        WASD: Move | Space: Jump | Click: Shoot
      </div>
    </div>
  );
};

export default FPSGame;
          
