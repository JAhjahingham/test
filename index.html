import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';

export default function FPSGame() {
  const mountRef = useRef(null);
  const [score, setScore] = useState(0);
  const [health, setHealth] = useState(100);
  const [ammo, setAmmo] = useState(30);
  const [gameOver, setGameOver] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);

  useEffect(() => {
    if (!isPlaying || !mountRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    mountRef.current.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x3a8c3a });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Create walls/obstacles
    const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
    const walls = [];
    const wallPositions = [
      [0, 1.5, -20, 30, 3, 1],
      [-20, 1.5, 0, 1, 3, 30],
      [20, 1.5, 0, 1, 3, 30],
      [0, 1.5, 20, 30, 3, 1],
      [-10, 1.5, -10, 5, 3, 1],
      [10, 1.5, 10, 1, 3, 8]
    ];
    
    wallPositions.forEach(pos => {
      const wall = new THREE.Mesh(
        new THREE.BoxGeometry(pos[3], pos[4], pos[5]),
        wallMaterial
      );
      wall.position.set(pos[0], pos[1], pos[2]);
      wall.castShadow = true;
      wall.receiveShadow = true;
      scene.add(wall);
      walls.push(wall);
    });

    // Game state
    const gameState = {
      health: 100,
      score: 0,
      ammo: 30,
      enemies: [],
      bullets: [],
      playerPos: new THREE.Vector3(0, 1.6, 0),
      playerVelocity: new THREE.Vector3(0, 0, 0),
      camera: camera,
      rotation: { yaw: 0, pitch: 0 },
      keys: {},
      mouseMovement: { x: 0, y: 0 },
      lastShot: 0,
      isPointerLocked: false
    };

    // Enemy class
    class Enemy {
      constructor(x, z) {
        const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
        const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.9, z);
        this.mesh.castShadow = true;
        scene.add(this.mesh);
        this.health = 100;
        this.speed = 0.02;
        this.lastAttack = 0;
      }

      update(playerPos, currentTime) {
        // Move toward player
        const direction = new THREE.Vector3();
        direction.subVectors(playerPos, this.mesh.position);
        direction.y = 0;
        direction.normalize();
        
        this.mesh.position.x += direction.x * this.speed;
        this.mesh.position.z += direction.z * this.speed;

        // Attack player if close
        const distance = this.mesh.position.distanceTo(playerPos);
        if (distance < 2 && currentTime - this.lastAttack > 1000) {
          this.lastAttack = currentTime;
          return 10; // Damage to player
        }
        return 0;
      }

      takeDamage(damage) {
        this.health -= damage;
        return this.health <= 0;
      }

      remove() {
        scene.remove(this.mesh);
      }
    }

    // Spawn enemies
    function spawnEnemy() {
      const angle = Math.random() * Math.PI * 2;
      const distance = 15 + Math.random() * 10;
      const x = Math.cos(angle) * distance;
      const z = Math.sin(angle) * distance;
      gameState.enemies.push(new Enemy(x, z));
    }

    // Initial enemies
    for (let i = 0; i < 5; i++) {
      spawnEnemy();
    }

    // Weapon (visible gun)
    const gunGroup = new THREE.Group();
    const gunBody = new THREE.Mesh(
      new THREE.BoxGeometry(0.1, 0.1, 0.5),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    gunBody.position.set(0.3, -0.2, -0.5);
    gunGroup.add(gunBody);
    camera.add(gunGroup);
    scene.add(camera);

    // Crosshair
    const crosshairGeometry = new THREE.PlaneGeometry(0.02, 0.02);
    const crosshairMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const crosshair = new THREE.Mesh(crosshairGeometry, crosshairMaterial);
    crosshair.position.z = -1;
    camera.add(crosshair);

    // Event listeners
    const handleKeyDown = (e) => { gameState.keys[e.code] = true; };
    const handleKeyUp = (e) => { gameState.keys[e.code] = false; };
    
    const handleMouseMove = (e) => {
      if (!gameState.isPointerLocked) return;
      gameState.mouseMovement.x = e.movementX || 0;
      gameState.mouseMovement.y = e.movementY || 0;
    };

    const handleClick = () => {
      if (!gameState.isPointerLocked) {
        renderer.domElement.requestPointerLock();
      } else {
        shoot();
      }
    };

    const handlePointerLockChange = () => {
      gameState.isPointerLocked = document.pointerLockElement === renderer.domElement;
    };

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    document.addEventListener('mousemove', handleMouseMove);
    renderer.domElement.addEventListener('click', handleClick);
    document.addEventListener('pointerlockchange', handlePointerLockChange);

    // Shooting
    function shoot() {
      const currentTime = Date.now();
      if (currentTime - gameState.lastShot < 200 || gameState.ammo <= 0) return;
      
      gameState.lastShot = currentTime;
      gameState.ammo--;
      setAmmo(gameState.ammo);

      // Gun recoil animation
      gunGroup.position.z += 0.1;
      setTimeout(() => { gunGroup.position.z -= 0.1; }, 100);

      // Raycasting for hit detection
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

      const enemyMeshes = gameState.enemies.map(e => e.mesh);
      const intersects = raycaster.intersectObjects(enemyMeshes);

      if (intersects.length > 0) {
        const hitEnemy = gameState.enemies.find(e => e.mesh === intersects[0].object);
        if (hitEnemy && hitEnemy.takeDamage(34)) {
          hitEnemy.remove();
          gameState.enemies = gameState.enemies.filter(e => e !== hitEnemy);
          gameState.score += 100;
          setScore(gameState.score);
          
          // Spawn new enemy
          if (gameState.enemies.length < 8) {
            spawnEnemy();
          }
        }
      }
    }

    // Reload
    function reload() {
      if (gameState.ammo < 30) {
        gameState.ammo = 30;
        setAmmo(30);
      }
    }

    // Handle R key for reload
    const handleReload = (e) => {
      if (e.code === 'KeyR') reload();
    };
    document.addEventListener('keydown', handleReload);

    // Animation loop
    const animate = () => {
      if (gameState.health <= 0) {
        setGameOver(true);
        return;
      }

      requestAnimationFrame(animate);

      // Mouse look
      if (gameState.isPointerLocked) {
        gameState.rotation.yaw -= gameState.mouseMovement.x * 0.002;
        gameState.rotation.pitch -= gameState.mouseMovement.y * 0.002;
        gameState.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameState.rotation.pitch));
        gameState.mouseMovement.x = 0;
        gameState.mouseMovement.y = 0;
      }

      // Apply rotation
      camera.rotation.order = 'YXZ';
      camera.rotation.y = gameState.rotation.yaw;
      camera.rotation.x = gameState.rotation.pitch;

      // Movement
      const moveSpeed = 0.1;
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
      forward.y = 0;
      right.y = 0;
      forward.normalize();
      right.normalize();

      if (gameState.keys['KeyW']) gameState.playerPos.addScaledVector(forward, moveSpeed);
      if (gameState.keys['KeyS']) gameState.playerPos.addScaledVector(forward, -moveSpeed);
      if (gameState.keys['KeyA']) gameState.playerPos.addScaledVector(right, -moveSpeed);
      if (gameState.keys['KeyD']) gameState.playerPos.addScaledVector(right, moveSpeed);

      // Boundaries
      gameState.playerPos.x = Math.max(-48, Math.min(48, gameState.playerPos.x));
      gameState.playerPos.z = Math.max(-48, Math.min(48, gameState.playerPos.z));

      camera.position.copy(gameState.playerPos);

      // Update enemies
      const currentTime = Date.now();
      gameState.enemies.forEach(enemy => {
        const damage = enemy.update(gameState.playerPos, currentTime);
        if (damage > 0) {
          gameState.health -= damage;
          setHealth(gameState.health);
        }
      });

      renderer.render(scene, camera);
    };

    animate();

    // Cleanup
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('keydown', handleReload);
      document.removeEventListener('pointerlockchange', handlePointerLockChange);
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [isPlaying]);

  const startGame = () => {
    setIsPlaying(true);
    setGameOver(false);
    setScore(0);
    setHealth(100);
    setAmmo(30);
  };

  return (
    <div className="w-full h-screen bg-black relative">
      <div ref={mountRef} className="w-full h-full" />
      
      {/* HUD */}
      {isPlaying && !gameOver && (
        <div className="absolute top-0 left-0 right-0 p-4 text-white font-mono">
          <div className="flex justify-between items-start">
            <div>
              <div className="text-2xl font-bold">Health: {health}</div>
              <div className="text-xl">Score: {score}</div>
              <div className="text-xl">Ammo: {ammo}/30</div>
            </div>
            <div className="text-right text-sm opacity-75">
              <div>WASD - Move</div>
              <div>Mouse - Look</div>
              <div>Click - Shoot</div>
              <div>R - Reload</div>
            </div>
          </div>
        </div>
      )}

      {/* Start Screen */}
      {!isPlaying && !gameOver && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80">
          <div className="text-center text-white">
            <h1 className="text-6xl font-bold mb-8">FPS SHOOTER</h1>
            <button
              onClick={startGame}
              className="px-8 py-4 bg-red-600 hover:bg-red-700 text-white text-2xl font-bold rounded transition"
            >
              START GAME
            </button>
            <div className="mt-8 text-gray-300">
              <p>Click to lock pointer and start playing</p>
              <p className="mt-2">Eliminate all enemies to win!</p>
            </div>
          </div>
        </div>
      )}

      {/* Game Over */}
      {gameOver && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-90">
          <div className="text-center text-white">
            <h1 className="text-6xl font-bold mb-4 text-red-600">GAME OVER</h1>
            <p className="text-3xl mb-8">Final Score: {score}</p>
            <button
              onClick={startGame}
              className="px-8 py-4 bg-red-600 hover:bg-red-700 text-white text-2xl font-bold rounded transition"
            >
              PLAY AGAIN
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
