<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Defense</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /*
        Custom CSS for a retro, arcade aesthetic.
        We are using the 'Press Start 2P' font for a classic look.
        */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            padding: 10px;
        }

        #game-container {
            position: relative;
            background-color: #000000;
            border: 5px solid #00ff41; /* Neon green border */
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.7);
            max-width: 90vw;
            width: 600px; /* Base size, will scale */
            height: 700px; /* Base size, will scale */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            margin-top: 15px;
        }

        .control-button {
            padding: 15px 30px;
            font-size: 14px;
            font-family: 'Press Start 2P', cursive;
            background-color: #ff0077; /* Neon pink */
            color: #000000;
            border: 3px solid #ffffff;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 5px 0 #9e004b;
            transition: all 0.1s ease;
            user-select: none; /* Prevent text selection */
        }

        .control-button:active {
            box-shadow: 0 2px 0 #9e004b;
            transform: translateY(3px);
        }

        #fire-button {
            background-color: #00ff41; /* Neon green */
            box-shadow: 0 5px 0 #009e29;
            color: #000000;
        }

        #fire-button:active {
            box-shadow: 0 2px 0 #009e29;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.9);
            text-align: center;
            z-index: 10;
        }

        h1 {
            font-size: 24px;
            color: #00ff41;
            text-shadow: 0 0 10px #00ff41;
            margin-bottom: 20px;
        }

        p {
            font-size: 12px;
            margin: 10px 0;
            color: #ffffff;
        }

        .score-display {
            font-size: 16px;
            margin-bottom: 20px;
            color: #ff0077;
        }

        #start-button, #restart-button {
            padding: 15px 30px;
            font-size: 16px;
            font-family: 'Press Start 2P', cursive;
            background-color: #ff0077;
            color: #000000;
            border: 3px solid #ffffff;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 5px 0 #9e004b;
            transition: all 0.1s ease;
        }
        
        #start-button:active, #restart-button:active {
            box-shadow: 0 2px 0 #9e004b;
            transform: translateY(3px);
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 650px) {
            #game-container {
                max-width: 95vw;
                height: 80vh;
                max-height: 600px;
            }
            .control-button {
                padding: 10px 20px;
                font-size: 10px;
            }
            #controls {
                max-width: 95vw;
            }
            h1 {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- Start Screen -->
        <div id="start-screen">
            <h1>COSMIC DEFENSE</h1>
            <p>Controls (Desktop):</p>
            <p>&#x2190; / A: Move Left</p>
            <p>&#x2192; / D: Move Right</p>
            <p>SPACE: Fire</p>
            <p class="score-display">Defend humanity from the invading fleet!</p>
            <button id="start-button">START GAME</button>
        </div>

        <!-- Game Over Screen (Hidden initially) -->
        <div id="game-over-screen" style="display: none;">
            <h1>GAME OVER</h1>
            <p id="final-score" class="score-display"></p>
            <button id="restart-button">RETRY</button>
        </div>
    </div>

    <!-- On-screen controls for mobile/touch -->
    <div id="controls">
        <button id="left-button" class="control-button">&#x2190; MOVE LEFT</button>
        <button id="fire-button" class="control-button">FIRE</button>
        <button id="right-button" class="control-button">MOVE RIGHT &#x2192;</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const finalScoreDisplay = document.getElementById('final-score');

        // Game State Variables
        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let keys = {};
        let touchMoveDir = 0; // -1 for left, 1 for right, 0 for stop

        // Dimensions
        let gameWidth;
        let gameHeight;

        // Player (Cannon) Object
        let player = {
            width: 30,
            height: 20,
            x: 0,
            y: 0,
            speed: 5,
            color: '#00ff41' // Neon Green
        };

        // Arrays for dynamic elements
        let playerBullets = [];
        let enemies = [];
        let enemyBullets = [];

        // Game Constants
        const ENEMY_ROWS = 5;
        const ENEMIES_PER_ROW = 8;
        const ENEMY_SPACING = 50;
        const ENEMY_BULLET_SPEED = 3;
        const PLAYER_BULLET_SPEED = 7;
        let ENEMY_SPEED = 0.5;
        let enemyDirection = 1; // 1 for right, -1 for left
        let lastEnemyFireTime = 0;
        const ENEMY_FIRE_RATE = 1500; // ms

        // Utility function for drawing rounded rectangles (player/enemies)
        function drawRoundedRect(x, y, w, h, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.arcTo(x + w, y, x + w, y + radius, radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.arcTo(x + w, y + h, x + w - radius, y + h, radius);
            ctx.lineTo(x + radius, y + h);
            ctx.arcTo(x, y + h, x, y + h - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.fill();
        }

        // --- Core Game Logic Functions ---

        function setupGame() {
            // Calculate dimensions based on container
            const container = document.getElementById('game-container');
            gameWidth = container.clientWidth;
            gameHeight = container.clientHeight;
            canvas.width = gameWidth;
            canvas.height = gameHeight;

            // Initialize player position
            player.x = (gameWidth - player.width) / 2;
            player.y = gameHeight - player.height - 20;

            // Reset state
            score = 0;
            lives = 3;
            keys = {};
            playerBullets = [];
            enemyBullets = [];
            enemies = [];
            enemyDirection = 1;
            ENEMY_SPEED = 0.5;
            lastEnemyFireTime = 0;

            createEnemies();

            // Hide screens
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';

            if (!gameRunning) {
                gameRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }

        function createEnemies() {
            const enemyWidth = 25;
            const enemyHeight = 15;
            const startX = (gameWidth - (ENEMIES_PER_ROW * ENEMY_SPACING - (ENEMY_SPACING - enemyWidth))) / 2;
            const startY = 50;
            const colors = ['#ff6f00', '#ff0077', '#00eaff', '#00ff41', '#ffffff']; // Orange, Pink, Cyan, Green, White

            for (let row = 0; row < ENEMY_ROWS; row++) {
                for (let col = 0; col < ENEMIES_PER_ROW; col++) {
                    enemies.push({
                        width: enemyWidth,
                        height: enemyHeight,
                        x: startX + col * ENEMY_SPACING,
                        y: startY + row * ENEMY_SPACING,
                        color: colors[row],
                        row: row,
                        col: col,
                        isAlive: true,
                        pointValue: (ENEMY_ROWS - row) * 10
                    });
                }
            }
        }

        function drawGame() {
            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, gameWidth, gameHeight);

            // Draw Score and Lives
            ctx.fillStyle = '#ffffff';
            ctx.font = "10px 'Press Start 2P'";
            ctx.fillText(`SCORE: ${score}`, 10, 20);
            ctx.fillText(`LIVES: ${lives}`, gameWidth - 100, 20);

            // Draw Player
            drawRoundedRect(player.x, player.y, player.width, player.height, 3, player.color);

            // Draw Player Bullets
            playerBullets.forEach(bullet => {
                ctx.fillStyle = '#ffff00'; // Yellow
                ctx.fillRect(bullet.x, bullet.y, 2, 8);
            });

            // Draw Enemies
            enemies.forEach(enemy => {
                if (enemy.isAlive) {
                    drawRoundedRect(enemy.x, enemy.y, enemy.width, enemy.height, 3, enemy.color);
                }
            });

            // Draw Enemy Bullets
            enemyBullets.forEach(bullet => {
                ctx.fillStyle = '#ff0077'; // Neon Pink
                ctx.fillRect(bullet.x, bullet.y, 3, 6);
            });
        }

        function updateGame(deltaTime) {
            if (!gameRunning) return;

            // 1. Update Player Movement (Keyboard & Touch)
            let moveDelta = 0;
            if (keys['ArrowLeft'] || keys['a']) moveDelta -= 1;
            if (keys['ArrowRight'] || keys['d']) moveDelta += 1;
            moveDelta += touchMoveDir;

            player.x += moveDelta * player.speed;

            // Keep player within bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > gameWidth) player.x = gameWidth - player.width;

            // 2. Update Player Bullets
            playerBullets = playerBullets.filter(bullet => {
                bullet.y -= PLAYER_BULLET_SPEED;

                // Check for collision with enemies
                let hitEnemy = false;
                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    if (enemy.isAlive && checkCollision(bullet, enemy)) {
                        enemy.isAlive = false;
                        score += enemy.pointValue;
                        hitEnemy = true;
                        // Speed up enemies slightly every time one is defeated
                        ENEMY_SPEED += 0.02;
                        break;
                    }
                }

                // Keep bullet if it's on screen and didn't hit an enemy
                return bullet.y > 0 && !hitEnemy;
            });
            
            // If all enemies are cleared, restart with faster enemies
            const livingEnemies = enemies.filter(e => e.isAlive);
            if (livingEnemies.length === 0) {
                ENEMY_SPEED += 0.5; // Next wave is faster
                createEnemies();
            }

            // 3. Update Enemies
            let shouldDescend = false;
            let maxEnemyX = 0;
            let minEnemyX = gameWidth;

            // Calculate min/max X of living enemies
            livingEnemies.forEach(enemy => {
                maxEnemyX = Math.max(maxEnemyX, enemy.x + enemy.width);
                minEnemyX = Math.min(minEnemyX, enemy.x);
            });

            // Check if boundary is hit
            if (maxEnemyX + ENEMY_SPEED * enemyDirection > gameWidth || minEnemyX + ENEMY_SPEED * enemyDirection < 0) {
                enemyDirection *= -1; // Reverse direction
                shouldDescend = true;
            }
            
            // Move enemies
            livingEnemies.forEach(enemy => {
                enemy.x += ENEMY_SPEED * enemyDirection;
                if (shouldDescend) {
                    enemy.y += 20; // Move down one row
                }
                
                // Check if enemies reached the player's level
                if (enemy.y + enemy.height >= player.y) {
                    endGame('Game Over: The Invaders landed!');
                }
            });

            // 4. Enemy Fire
            const now = Date.now();
            if (now - lastEnemyFireTime > ENEMY_FIRE_RATE * (1 / (ENEMY_SPEED/0.5))) { // Fire rate speeds up with enemy speed
                const firingEnemies = livingEnemies;
                if (firingEnemies.length > 0) {
                    const shooter = firingEnemies[Math.floor(Math.random() * firingEnemies.length)];
                    enemyBullets.push({
                        x: shooter.x + shooter.width / 2 - 1.5,
                        y: shooter.y + shooter.height,
                        width: 3,
                        height: 6
                    });
                    lastEnemyFireTime = now;
                }
            }
            
            // 5. Update Enemy Bullets and Check Player Collision
            enemyBullets = enemyBullets.filter(bullet => {
                bullet.y += ENEMY_BULLET_SPEED;

                if (checkCollision(bullet, player)) {
                    lives--;
                    if (lives <= 0) {
                        endGame('Game Over: You were destroyed!');
                    }
                    // Bullet is consumed on impact
                    return false;
                }

                // Keep bullet if it's on screen
                return bullet.y < gameHeight;
            });
        }

        // --- Collision Detection ---
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }


        // --- Game State Management ---

        function shoot() {
            // Only allow one player bullet on screen at a time for classic feel
            if (playerBullets.length === 0 && gameRunning) {
                playerBullets.push({
                    x: player.x + player.width / 2 - 1, // Center the bullet
                    y: player.y,
                    width: 2,
                    height: 8
                });
            }
        }

        function endGame(message) {
            gameRunning = false;
            finalScoreDisplay.textContent = `${message} Final Score: ${score}`;
            gameOverScreen.style.display = 'flex';
        }

        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameRunning) return;

            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            updateGame(deltaTime);
            drawGame();

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---

        // Desktop Controls
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault(); // Prevent scrolling
                if (gameRunning) shoot();
            }
            if (['ArrowLeft', 'ArrowRight', 'a', 'd'].includes(e.key.toLowerCase())) {
                keys[e.key.toLowerCase()] = true;
                keys[e.key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (['ArrowLeft', 'ArrowRight', 'a', 'd'].includes(e.key.toLowerCase())) {
                keys[e.key.toLowerCase()] = false;
                keys[e.key] = false;
            }
        });

        // Mobile/Touch Controls
        document.getElementById('left-button').addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchMoveDir = -1;
        });
        document.getElementById('right-button').addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchMoveDir = 1;
        });
        document.getElementById('fire-button').addEventListener('touchstart', (e) => {
            e.preventDefault();
            shoot();
        });

        document.getElementById('left-button').addEventListener('touchend', () => { touchMoveDir = 0; });
        document.getElementById('right-button').addEventListener('touchend', () => { touchMoveDir = 0; });

        document.getElementById('left-button').addEventListener('mousedown', () => { touchMoveDir = -1; });
        document.getElementById('right-button').addEventListener('mousedown', () => { touchMoveDir = 1; });
        document.getElementById('fire-button').addEventListener('mousedown', shoot);

        document.getElementById('left-button').addEventListener('mouseup', () => { touchMoveDir = 0; });
        document.getElementById('right-button').addEventListener('mouseup', () => { touchMoveDir = 0; });

        // Start/Restart Buttons
        startButton.addEventListener('click', setupGame);
        restartButton.addEventListener('click', setupGame);

        // Window resize to maintain responsiveness
        window.addEventListener('resize', () => {
            if (gameRunning) {
                setupGame(); // Re-initializes everything to fit new size
            } else {
                // Just resize canvas for correct initial sizing if game hasn't started
                const container = document.getElementById('game-container');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawGame(); // Redraw initial empty state
            }
        });

        // Initial setup on load
        window.onload = function() {
            // Set initial canvas size
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

    </script>
</body>
</html>
